/** 
 * SKY CORE V2.0 - ENHANCED GOOGLE APPS SCRIPT
 * 
 * Features:
 * - Server-side player data calculations
 * - Safety indicators (warmup/core completion rates)
 * - Streak calculation (consecutive weeks)
 * - Workout history (last 12 workouts)
 * - Section-level completion tracking
 * - DELETE endpoint for permanent player removal
 */

// ========== MAIN ENDPOINTS ==========

/**
 * GET endpoint - Returns comprehensive dashboard data OR handles delete
 */
function doGet(e) {
  try {
    // Handle DELETE requests via GET parameter
    if (e.parameter && e.parameter.deletePlayer) {
      const playerName = e.parameter.deletePlayer;
      return deletePlayerFromSheet(playerName);
    }
    
    // Return comprehensive dashboard data
    const ss = SpreadsheetApp.getActive();
    const sh = ss.getSheetByName('Logs');
    
    if (!sh || sh.getLastRow() < 2) {
      return json({ ok: true, timestamp: new Date().toISOString(), players: {} });
    }
    
    const values = sh.getDataRange().getValues();
    const headers = values[0];
    const rows = values.slice(1);
    
    // Group rows by player
    const playerRows = groupRowsByPlayer(rows, headers);
    
    // Build comprehensive data for each player
    const players = {};
    for (const playerName in playerRows) {
      players[playerName] = buildPlayerData(playerName, playerRows[playerName], headers);
    }
    
    return json({
      ok: true,
      timestamp: new Date().toISOString(),
      players: players
    });
    
  } catch (err) {
    return json({ ok: false, error: String(err) });
  }
}

/**
 * POST endpoint - Receives workout data from player app (UPSERT logic)
 */
function doPost(e) {
  try {
    const p = JSON.parse(e.postData.contents);
    
    // Handle DELETE action via POST
    if (p.action === 'deletePlayer') {
      const playerName = p.name;
      if (!playerName) {
        return json({ ok: false, error: 'No player name provided' });
      }
      return deletePlayerFromSheet(playerName);
    }
    
    // Original UPSERT logic for workout data
    const ss = SpreadsheetApp.getActive();
    const sh = ss.getSheetByName('Logs') || ss.insertSheet('Logs');
    
    const HEADERS = [
      'ts', 'player', 'week', 'day', 'section', 'item', 'set',
      'done', 'weight', 'notes', 'xp'
    ];
    
    if (sh.getLastRow() === 0) sh.appendRow(HEADERS);
    
    // Build a map of existing rows keyed by unique exercise identity
    const data = sh.getDataRange().getValues();
    const idx = Object.fromEntries(HEADERS.map((h, i) => [h, i]));
    const keyOf = r => [
      r[idx.player], r[idx.week], r[idx.day],
      r[idx.section], r[idx.item], r[idx.set] || ''
    ].join('||');
    
    const rowMap = new Map();
    for (let r = 2; r <= data.length; r++) {
      const row = data[r - 1];
      rowMap.set(keyOf(row), r);
    }
    
    // Expand the incoming payload to flat rows
    const rows = [];
    const d = p.entry || {};
    
    const addRow = (section, item, setNo, done, weight, notes) => rows.push([
      p.ts, p.player, p.week, p.day, section, item, setNo || '',
      done ? 'yes' : 'no', weight || '', notes || '',
      p.xp
    ]);
    
    const names = (sec) => getProgramNames(p.day, sec);
    
    ['warmup', 'core', 'jump'].forEach(sec => {
      const list = d[sec] || [];
      const label = names(sec);
      list.forEach((ck, i) => addRow(cap(sec), label[i] || '', '', !!ck));
    });
    
    const strengthPlan = getProgramStrength(p.day);
    (d.strength || []).forEach((blk, i) => {
      const name = (strengthPlan[i] && strengthPlan[i].ex) || '';
      (blk.sets || []).forEach((s, si) => {
        addRow('Strength', name, si + 1, !!s.done, blk.weight, blk.notes);
      });
    });
    
    // UPSERT: update existing row if key found, else append
    const updates = [];
    const appends = [];
    
    rows.forEach(r => {
      const k = [r[idx.player], r[idx.week], r[idx.day], r[idx.section], r[idx.item], r[idx.set] || ''].join('||');
      const at = rowMap.get(k);
      if (at) {
        updates.push({ row: at, values: r });
      } else {
        appends.push(r);
      }
    });
    
    // Batch update existing rows
    if (updates.length) {
      updates.sort((a, b) => a.row - b.row);
      updates.forEach(u => {
        sh.getRange(u.row, 1, 1, HEADERS.length).setValues([u.values]);
      });
    }
    
    // Batch append new rows
    if (appends.length) {
      sh.getRange(sh.getLastRow() + 1, 1, appends.length, HEADERS.length).setValues(appends);
    }
    
    return json({ ok: true, updated: updates.length, inserted: appends.length });
    
  } catch (err) {
    return json({ ok: false, error: String(err) });
  }
}

// ========== DELETE FUNCTION ==========

/**
 * Delete all rows for a given player from the Logs sheet
 */
function deletePlayerFromSheet(playerName) {
  if (!playerName) {
    return json({ ok: false, error: 'No player name provided' });
  }
  
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Logs');
  
  if (!sh) {
    return json({ ok: false, error: 'Logs sheet not found' });
  }
  
  const lastRow = sh.getLastRow();
  if (lastRow < 2) {
    return json({ ok: true, message: 'No data to delete', deleted: 0 });
  }
  
  // Get all data to find matching rows
  const data = sh.getDataRange().getValues();
  const playerColIndex = 1; // Column B (0-indexed, so 1 = column B)
  const toDelete = [];
  
  // Find rows with matching player name (skip header row 0)
  for (let i = data.length - 1; i > 0; i--) {
    if (String(data[i][playerColIndex]).trim() === playerName.trim()) {
      toDelete.push(i + 1); // +1 because sheet rows are 1-indexed
    }
  }
  
  // Delete rows in reverse order (bottom to top) to maintain indices
  toDelete.forEach(rowNum => {
    sh.deleteRow(rowNum);
  });
  
  return json({
    ok: true,
    deleted: toDelete.length,
    player: playerName
  });
}

// ========== DATA PROCESSING FUNCTIONS ==========

/**
 * Group rows by player name
 */
function groupRowsByPlayer(rows, headers) {
  const playerCol = headers.indexOf('player');
  const grouped = {};
  
  rows.forEach(row => {
    const name = String(row[playerCol] || '').trim();
    if (!name) return;
    
    if (!grouped[name]) {
      grouped[name] = [];
    }
    grouped[name].push(row);
  });
  
  return grouped;
}

/**
 * Build comprehensive player data object
 */
function buildPlayerData(playerName, rows, headers) {
  // Get column indices
  const idx = {
    ts: headers.indexOf('ts'),
    player: headers.indexOf('player'),
    week: headers.indexOf('week'),
    day: headers.indexOf('day'),
    section: headers.indexOf('section'),
    item: headers.indexOf('item'),
    set: headers.indexOf('set'),
    done: headers.indexOf('done'),
    weight: headers.indexOf('weight'),
    notes: headers.indexOf('notes'),
    xp: headers.indexOf('xp')
  };
  
  // Sort rows by timestamp (most recent first)
  const sortedRows = rows.sort((a, b) => {
    const tsA = new Date(a[idx.ts] || 0).getTime();
    const tsB = new Date(b[idx.ts] || 0).getTime();
    return tsB - tsA;
  });
  
  // Get latest values
  const latest = sortedRows[0];
  const currentWeek = Number(latest[idx.week] || 1);
  const currentDay = Number(latest[idx.day] || 1);
  const xp = Number(latest[idx.xp] || 0);
  
  // Count total workouts (unique week+day combinations with completed exercises)
  const totalWorkouts = countTotalWorkouts(rows, idx);
  
  // Get current workout data
  const currentWorkout = getCurrentWorkout(rows, idx, currentWeek, currentDay);
  
  // Calculate safety indicators
  const safety = calculateSafety(rows, idx);
  
  // Build history (last 12 workouts)
  const history = buildHistory(rows, idx, 12);
  
  return {
    name: playerName,
    currentWeek: currentWeek,
    currentDay: currentDay,
    xp: xp,
    totalWorkouts: totalWorkouts,
    currentWorkout: currentWorkout,
    safety: safety,
    history: history,
    messages: []  // Phase 2: Real-time messaging
  };
}

/**
 * Count total workouts (unique week+day with completed exercises)
 */
function countTotalWorkouts(rows, idx) {
  const workouts = new Set();
  
  rows.forEach(row => {
    const done = String(row[idx.done] || '').toLowerCase();
    if (done === 'yes') {
      const week = Number(row[idx.week] || 0);
      const day = Number(row[idx.day] || 0);
      if (week > 0 && day > 0) {
        workouts.add(`${week}-${day}`);
      }
    }
  });
  
  return workouts.size;
}

/**
 * Get current workout data with section-level breakdown
 */
function getCurrentWorkout(rows, idx, week, day) {
  // Filter rows for current week/day
  const currentRows = rows.filter(row => {
    return Number(row[idx.week]) === week && Number(row[idx.day]) === day;
  });
  
  if (currentRows.length === 0) {
    return {
      week: week,
      day: day,
      completed: 0,
      total: 0,
      percentage: 0,
      sections: {
        warmup: { done: 0, total: 0, percentage: 0 },
        core: { done: 0, total: 0, percentage: 0 },
        jump: { done: 0, total: 0, percentage: 0 },
        strength: { done: 0, total: 0, percentage: 0 }
      },
      notes: ""
    };
  }
  
  // Count by section
  const sections = {
    warmup: { done: 0, total: 0 },
    core: { done: 0, total: 0 },
    jump: { done: 0, total: 0 },
    strength: { done: 0, total: 0 }
  };
  
  let totalDone = 0;
  let totalCount = 0;
  let notes = "";
  
  currentRows.forEach(row => {
    const section = String(row[idx.section] || '').toLowerCase();
    const done = String(row[idx.done] || '').toLowerCase() === 'yes';
    const rowNotes = String(row[idx.notes] || '').trim();
    
    if (rowNotes && !notes) {
      notes = rowNotes;
    }
    
    if (sections[section] !== undefined) {
      sections[section].total++;
      totalCount++;
      
      if (done) {
        sections[section].done++;
        totalDone++;
      }
    }
  });
  
  // Calculate percentages
  for (const section in sections) {
    const s = sections[section];
    s.percentage = s.total > 0 ? Math.round((s.done / s.total) * 100) : 0;
  }
  
  const percentage = totalCount > 0 ? Math.round((totalDone / totalCount) * 100) : 0;
  
  return {
    week: week,
    day: day,
    completed: totalDone,
    total: totalCount,
    percentage: percentage,
    sections: sections,
    notes: notes
  };
}

/**
 * Calculate safety indicators
 */
function calculateSafety(rows, idx) {
  // Group by workout (week + day)
  const workouts = {};
  
  rows.forEach(row => {
    const week = Number(row[idx.week] || 0);
    const day = Number(row[idx.day] || 0);
    const workoutKey = `${week}-${day}`;
    
    if (!workouts[workoutKey]) {
      workouts[workoutKey] = {
        week: week,
        day: day,
        warmup: { done: 0, total: 0 },
        core: { done: 0, total: 0 },
        timestamp: row[idx.ts]
      };
    }
    
    const section = String(row[idx.section] || '').toLowerCase();
    const done = String(row[idx.done] || '').toLowerCase() === 'yes';
    
    if (section === 'warmup') {
      workouts[workoutKey].warmup.total++;
      if (done) workouts[workoutKey].warmup.done++;
    } else if (section === 'core') {
      workouts[workoutKey].core.total++;
      if (done) workouts[workoutKey].core.done++;
    }
  });
  
  // Calculate completion rates
  let warmupWorkouts = 0;
  let warmupComplete = 0;
  let coreWorkouts = 0;
  let coreComplete = 0;
  let lastActivity = null;
  
  for (const key in workouts) {
    const w = workouts[key];
    
    // Update last activity
    if (!lastActivity || new Date(w.timestamp) > new Date(lastActivity)) {
      lastActivity = w.timestamp;
    }
    
    // Count warmup completion (100% = complete)
    if (w.warmup.total > 0) {
      warmupWorkouts++;
      if (w.warmup.done === w.warmup.total) {
        warmupComplete++;
      }
    }
    
    // Count core completion (100% = complete)
    if (w.core.total > 0) {
      coreWorkouts++;
      if (w.core.done === w.core.total) {
        coreComplete++;
      }
    }
  }
  
  const warmupCompletionRate = warmupWorkouts > 0 
    ? Math.round((warmupComplete / warmupWorkouts) * 100) 
    : 0;
    
  const coreCompletionRate = coreWorkouts > 0 
    ? Math.round((coreComplete / coreWorkouts) * 100) 
    : 0;
  
  // Calculate days since last workout
  const daysSinceLastWorkout = lastActivity 
    ? Math.floor((Date.now() - new Date(lastActivity).getTime()) / (1000 * 60 * 60 * 24))
    : 999;
  
  // Determine workout frequency
  const workoutCount = Object.keys(workouts).length;
  let workoutFrequency = "Unknown";
  if (workoutCount >= 12) {
    workoutFrequency = "3x/week";
  } else if (workoutCount >= 6) {
    workoutFrequency = "Good";
  } else if (workoutCount >= 3) {
    workoutFrequency = "Low";
  } else {
    workoutFrequency = "Inconsistent";
  }
  
  // Determine status
  let status = "on_track";
  if (daysSinceLastWorkout > 7) {
    status = "at_risk";
  } else if (warmupCompletionRate < 70 || coreCompletionRate < 70) {
    status = "check_in";
  }
  
  return {
    warmupCompletionRate: warmupCompletionRate,
    coreCompletionRate: coreCompletionRate,
    lastActivity: lastActivity || new Date().toISOString(),
    daysSinceLastWorkout: daysSinceLastWorkout,
    workoutFrequency: workoutFrequency,
    status: status
  };
}

/**
 * Build workout history (last N workouts)
 */
function buildHistory(rows, idx, limit) {
  // Group by workout (week + day)
  const workouts = {};
  
  rows.forEach(row => {
    const week = Number(row[idx.week] || 0);
    const day = Number(row[idx.day] || 0);
    const workoutKey = `${week}-${day}`;
    
    if (!workouts[workoutKey]) {
      workouts[workoutKey] = {
        week: week,
        day: day,
        timestamp: row[idx.ts],
        done: 0,
        total: 0,
        notes: ""
      };
    }
    
    const w = workouts[workoutKey];
    w.total++;
    
    const done = String(row[idx.done] || '').toLowerCase() === 'yes';
    if (done) {
      w.done++;
    }
    
    const rowNotes = String(row[idx.notes] || '').trim();
    if (rowNotes && !w.notes) {
      w.notes = rowNotes;
    }
  });
  
  // Convert to array and sort by timestamp (most recent first)
  const history = Object.values(workouts).sort((a, b) => {
    return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
  });
  
  // Take top N and format
  return history.slice(0, limit).map(w => ({
    week: w.week,
    day: w.day,
    date: new Date(w.timestamp).toISOString().split('T')[0],
    completed: w.done,
    total: w.total,
    percentage: w.total > 0 ? Math.round((w.done / w.total) * 100) : 0,
    notes: w.notes
  }));
}

// ========== HELPER FUNCTIONS ==========

function json(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function cap(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function getProgramNames(day, section) {
  const P = {
    1: {
      warmup: ["Leg Swings — 10 each", "Walking Lunges — 10 each", "Bodyweight Squat — 3×10", "Standing Calf Raise — 3×10", "Light Jumps — 3×5"],
      core: ["Hanging Leg Raise — 3×10", "Plank — 3×30–45s"],
      jump: ["Two-step approach jumps — 5", "Touch rim/backboard — 3×5", "Form jumps — 3×10"]
    },
    2: {
      warmup: ["Arm Circles — 15/15", "Band Pull-Apart — 15", "Push-up to Down Dog — 8", "Shoulder Taps — 10/side", "Jumping Jacks — 30s"],
      core: ["Hanging Leg Raise — 3×10", "Side Plank — 3×30s each", "Stability Ball Roll-outs — 3×12", "Bird Dog — 3×10 each"],
      jump: ["MB Chest Pass — 3×10", "Overhead MB Slam — 3×10", "Clap or Plyo Push-ups — 3×6", "Sprint 20 yds × 6"]
    },
    3: {
      warmup: ["Dynamic Skips — 2×20 yds", "A-Skips & High Knees — 20 yds each", "Light Bounding — 2×10", "Submax Jumps — 3 at 50–70%"],
      core: ["Trap/Barbell Deadlift — 4×5", "Hip Thrust or Glute Bridge — 3×10"],
      jump: ["Two-step approach jumps — 8", "Touch rim/backboard — 3×5", "Dunk attempts — 5–10"]
    }
  };
  return (P[day] && P[day][section]) || [];
}

function getProgramStrength(day) {
  const S = {
    1: [
      { ex: "Back or Goblet Squat", sets: 4, reps: "6–8" },
      { ex: "Romanian Deadlift", sets: 3, reps: "8–10" },
      { ex: "Walking Lunges", sets: 3, reps: "10 each" },
      { ex: "Bulgarian Split Squat", sets: 3, reps: "8 each" },
      { ex: "Standing Calf Raise (Loaded)", sets: 4, reps: "12–15" }
    ],
    2: [
      { ex: "Barbell or DB Bench Press", sets: 4, reps: "6–8" },
      { ex: "Pull-Ups / Assisted Pull-Ups", sets: 3, reps: "6–10" },
      { ex: "Standing Overhead Press", sets: 3, reps: "8" },
      { ex: "1-Arm Dumbbell Row", sets: 3, reps: "10 each" },
      { ex: "Triceps Dips or Pushdowns", sets: 3, reps: "12–15" }
    ],
    3: [
      { ex: "Box Jump", sets: 4, reps: "5" },
      { ex: "Broad Jump", sets: 4, reps: "5" },
      { ex: "Lateral Bounds", sets: 3, reps: "6 each" },
      { ex: "Depth Drop → Vertical", sets: 3, reps: "5" },
      { ex: "Jump Squat (Bodyweight)", sets: 3, reps: "8" }
    ]
  };
  return S[day] || [];
}
